)
cols = c(
"ivory",
"green",
"gray88",
"#669933",
"cyan4",
"blue",
"cyan3",
"darkgray",
"gold",
"black",
"gold4",
"orangered3",
"darkgoldenrod1",
"gray",
"yellow",
"#33CCFF"
)
names(cols) = spaces
levels(allDatas$type) = spaces
#'\code{displayMap} Consruire la map de got en fonction
#'@param layerGeometry la couche donc la géometrie sera ajoutée et
#'@param layerCol pour fixer la couleur de la couche
#'@param layerFill pour fixer la couleur du remplissage
#'@return une novelle map
displayMap = function(layerGeometry=NA, layerCol="red", layerFill="red") {
map = ggplot(allDatas) + geom_sf(aes(fill = type), size = 0.1) +
geom_sf(data = locations,fill = "black",color = "black") +
scale_fill_manual("Lands category", values = cols) +
theme_minimal() +
geom_sf_interactive(data = locations, aes(tooltip = name), size = 2) +
geom_sf_text(
data = allDatas %>% filter(type == "continent"),
aes(label = name),
color = "red",
fontface = "bold"
)
if(!is.na(layerGeometry)){map = map + geom_sf(data = layerGeometry,
fill= layerFill,
color = layerCol) }
return (map)
}
displayMap()
setwd("~/Année d'Ing/3A Généraliste/visualisation des données/Projet-visualisation-Centrale-Casablanca")
source("importFilesAndDatas.R")
library(roxygen2)
#' creation d'une dataframe contenant toutes les datas utiles.
#' Pour pouvoir reconnaitre les differentes datas, ajout de l'attribut type
continents$type="continent"
islands$type="island"
lakes$type="lake"
rivers$type="river"
roads$type="road"
wall$type="wall"
allDatas = bind_rows( continents,islands, landscape, rivers,lakes,roads,wall)
spaces = c(
"continent",
"forest",
"mountain",
"stepp",
"swamp",
"lake",
"river",
"road",
"island",
"location",
"wall",
"political",
"desert",
"land",
"shore",
"water"
)
cols = c(
"ivory",
"green",
"gray88",
"#669933",
"cyan4",
"blue",
"cyan3",
"darkgray",
"gold",
"black",
"gold4",
"orangered3",
"darkgoldenrod1",
"gray",
"yellow",
"#33CCFF"
)
names(cols) = spaces
levels(allDatas$type) = spaces
#'\code{displayMap} Consruire la map de got en fonction
#'@param layerGeometry la couche donc la géometrie sera ajoutée et
#'@param layerCol pour fixer la couleur de la couche
#'@param layerFill pour fixer la couleur du remplissage
#'@return une novelle map
displayMap = function(layerGeometry=NA, layerCol="red", layerFill="red") {
map = ggplot(allDatas) + geom_sf(aes(fill = type), size = 0.1) +
geom_sf(data = locations,fill = "black",color = "black") +
scale_fill_manual("Lands category", values = cols) +
theme_minimal() +
geom_sf_interactive(data = locations, aes(tooltip = name), size = 2) +
geom_sf_text(
data = allDatas %>% filter(type == "continent"),
aes(label = name),
color = "red",
fontface = "bold"
)
if(!is.na(layerGeometry)){map = map + geom_sf(data = layerGeometry,
fill= layerFill,
color = layerCol) }
return (map)
}
displayMap()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
source("importFilesAndDatas.R")
#' getSeason est une fonction qui retourne les Ã©pisodes de la saison avec x
#' comme paramÃ¨tre correspondant Ã la saison en questio
getSeason<-function(x){
A<-episodes[episodes$seasonNum==x,]
liste_episodes<-A$episodeNum
liste_Id<-A$episodeId
return (as.data.frame(A))
}
getSeason(3)$episodeTitle
#retourne les Ã©pisodes
#Ã©pisode est une fonction qui retourne la liste des acteurs avec
epi<-function(x,y){
D<-getSeason(x)
D<-D[D$episodeNum==y,]
D<-D$episodeId
liste_scenes<-lapply(D,function(z){B<-scenes[scenes$episodeId==z,]
B<-B$sceneId}
)
liste_scenes<-unlist(liste_scenes)
liste_acteurs<-lapply(liste_scenes,function(e){T<-appearances[appearances$sceneId==e,]
T<-T$name   })
liste_acteurs<-unique(unlist(liste_acteurs))
return(liste_acteurs)
}
a<-epi(3,4)
source("importFilesAndDatas.R")
#' getSeason est une fonction qui retourne les Ã©pisodes de la saison avec x
#' comme paramÃ¨tre correspondant Ã la saison en questio
getSeason<-function(x){
A<-episodes[episodes$seasonNum==x,]
liste_episodes<-A$episodeNum
liste_Id<-A$episodeId
return (as.data.frame(A))
}
getSeason(3)$episodeTitle
#retourne les Ã©pisodes
#Ã©pisode est une fonction qui retourne la liste des acteurs avec
epi<-function(x,y){
D<-getSeason(x)
D<-D[D$episodeNum==y,]
D<-D$episodeId
liste_scenes<-lapply(D,function(z){B<-scenes[scenes$episodeId==z,]
B<-B$sceneId}
)
liste_scenes<-unlist(liste_scenes)
liste_acteurs<-lapply(liste_scenes,function(e){T<-appearances[appearances$sceneId==e,]
T<-T$name   })
liste_acteurs<-unique(unlist(liste_acteurs))
return(liste_acteurs)
}
a<-epi(3,4)
a
getSeasons <- function(numSeas) {
A <- episodes[episodes$seasonNum == numSeas, ]
liste_episodes <- A$episodeNum
liste_Id <- A$episodeId
#return (as.data.frame(A))
return (A)
}
getSeason(3)$episodeTitle
getSeason(3)
source("importFilesAndDatas.R")
#' getSeasons est une fonction qui retourne les Ã©pisodes de la saison avec numSeas
#' comme paramÃ¨tre correspondant Ã la saison en questio
getSeasons <- function(numSeas) {
A <- episodes[episodes$seasonNum == numSeas, ]
liste_episodes <- A$episodeNum
liste_Id <- A$episodeId
#return (as.data.frame(A))
return (A)
}
#getSeason(3)$episodeTitle
#retourne les Ã©pisodes
#Ã©pisode est une fonction qui retourne la liste des acteurs avec
getCharacters <- function(x, y) {
D <- getSeasons(x)
D <- D[D$episodeNum == y, ]
D <- D$episodeId
liste_scenes <- lapply(D, function(z) {
B <- scenes[scenes$episodeId == z, ]
B <- B$sceneId
})
liste_scenes <- unlist(liste_scenes)
liste_acteurs <-
lapply(liste_scenes, function(e) {
T <- appearances[appearances$sceneId == e, ]
T <-
T$name
})
liste_acteurs <- unique(unlist(liste_acteurs))
return(liste_acteurs)
}
getCharacters <- epi(3, 4)
getCharacters(3,4)
getCharacters <- function(x, y) {
D <- getSeasons(x)
D <- D[D$episodeNum == y, ]
D <- D$episodeId
liste_scenes <- lapply(D, function(z) {
B <- scenes[scenes$episodeId == z, ]
B <- B$sceneId
})
liste_scenes <- unlist(liste_scenes)
liste_acteurs <-
lapply(liste_scenes, function(e) {
T <- appearances[appearances$sceneId == e, ]
T <-
T$name
})
liste_acteurs <- unique(unlist(liste_acteurs))
return(liste_acteurs)
}
getCharacters(3,4)
getCharacters(1,1)
getSeasons(3)
a = getSeasons(3)
a$idAndTitle = a$episodeNum + a$episodeTitle
a$idAndTitle = as.string(a$episodeNum) + a$episodeTitle
a$idAndTitle = as.character(a$episodeNum) + a$episodeTitle
a$idAndTitle = paste(a$episodeNum,a$episodeTitle,sep=" ")
a
rm(list=ls())
source("importFilesAndDatas.R")
#' getSeason est une fonction qui retourne les Ã©pisodes de la saison avec numSeas
#' comme paramÃ¨tre correspondant Ã la saison en questio
getSeason <- function(numSeas) {
A <- episodes[episodes$seasonNum == numSeas, ]
#A$idAndTitle = past(A$episodeNum, A$episodeTitle, sep=" ")
#liste_episodes <- A$episodeNum
#liste_Id <- A$episodeId
#return (as.data.frame(A))
return (A)
}
#getSeason(3)$episodeTitle
#'\code{getCharacters} '@return list of characters in episode according
#'@param numseas season number and
#'@param numEpisode episode number
getCharacters <- function(numSeas, numEpisode) {
D <- getSeason(numSeas)
D <- D[D$episodeNum == numEpisode, ]
D <- D$episodeId
liste_scenes <- lapply(D, function(z) {
B <- scenes[scenes$episodeId == z, ]
B <- B$sceneId
})
liste_scenes <- unlist(liste_scenes)
liste_acteurs <-lapply(liste_scenes, function(e) {
T <- appearances[appearances$sceneId == e, ]
T <-T$name
})
liste_acteurs <- unique(unlist(liste_acteurs))
return(liste_acteurs)
}
getCharacters <- epi(3, 4)
getCharacters(3, 4)
runApp()
runApp()
setwd("~/Année d'Ing/3A Généraliste/visualisation des données/Projet-visualisation-Centrale-Casablanca")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
source("importFilesAndDatas.R")
#' getEpisodes est une fonction qui retourne les Ã©pisodes de la saison avec numSeas
#' comme paramÃ¨tre correspondant Ã la saison en questio
getEpisodes <- function(numSeas) {
A <- episodes[episodes$seasonNum == numSeas, ]
#A$idAndTitle = past(A$episodeNum, A$episodeTitle, sep=" ")
#liste_episodes <- A$episodeNum
#liste_Id <- A$episodeId
#return (as.data.frame(A))
return (A)
}
#'\code{getCharacters} '@return list of characters in episode according
#'@param numseas season number and
#'@param numEpisode episode number
getCharacters <- function(x, y) {
D <- getEpisodes(x)
D <- D[D$episodeNum == y, ]
D <- D$episodeId
liste_scenes <-
lapply(D, function(z) {
B <- scenes[scenes$episodeId == z, ]
B <- B$sceneId
})
liste_scenes <- unlist(liste_scenes)
liste_acteurs <-
lapply(liste_scenes, function(e) {
T <- appearances[appearances$sceneId == e, ]
T <- T$name
})
liste_acteurs <- unique(unlist(liste_acteurs))
return(liste_acteurs)
}
#getCharacters(3, 4)
getCharacters(3, 4)
runApp()
source("importFilesAndDatas.R")
#' getEpisodes est une fonction qui retourne les Ã©pisodes de la saison avec numSeas
#' comme paramÃ¨tre correspondant Ã la saison en questio
episodes$idAndTitle = past(episodes$episodeNum, episodes$episodeTitle, sep=" ")
getEpisodes <- function(numSeas) {
A <- episodes[episodes$seasonNum == numSeas, ]
#liste_episodes <- A$episodeNum
#liste_Id <- A$episodeId
#return (as.data.frame(A))
return (A)
}
#'\code{getCharacters} '@return list of characters in episode according
#'@param numseas season number and
#'@param numEpisode episode number
getCharacters <- function(x, y) {
D <- getEpisodes(x)
D <- D[D$episodeNum == y, ]
D <- D$episodeId
liste_scenes <-
lapply(D, function(z) {
B <- scenes[scenes$episodeId == z, ]
B <- B$sceneId
})
liste_scenes <- unlist(liste_scenes)
liste_acteurs <-
lapply(liste_scenes, function(e) {
T <- appearances[appearances$sceneId == e, ]
T <- T$name
})
liste_acteurs <- unique(unlist(liste_acteurs))
return(liste_acteurs)
}
#getCharacters(3, 4)
episodes$idAndTitle = past(episodes$episodeNum, episodes$episodeTitle, sep=" ")
source("importFilesAndDatas.R")
episodes$idAndTitle = past(episodes$episodeNum, episodes$episodeTitle, sep=" ")
getEpisodes <- function(numSeas) {
A <- episodes[episodes$seasonNum == numSeas, ]
A$idAndTitle = past(A$episodeNum, A$episodeTitle, sep=" ")
#liste_episodes <- A$episodeNum
#liste_Id <- A$episodeId
#return (as.data.frame(A))
return (A)
}
a=getEpisodes(4)
rm(list=ls())
source("importFilesAndDatas.R")
#' getEpisodes est une fonction qui retourne les Ã©pisodes de la saison avec numSeas
#' comme paramÃ¨tre correspondant Ã la saison en questio
getEpisodes <- function(numSeas) {
A <- episodes[episodes$seasonNum == numSeas, ]
A$idAndTitle = past(A$episodeNum, A$episodeTitle, sep=" ")
#liste_episodes <- A$episodeNum
#liste_Id <- A$episodeId
#return (as.data.frame(A))
return (A)
}
#'\code{getCharacters} '@return list of characters in episode according
#'@param numseas season number and
#'@param numEpisode episode number
getCharacters <- function(x, y) {
D <- getEpisodes(x)
D <- D[D$episodeNum == y, ]
D <- D$episodeId
liste_scenes <-
lapply(D, function(z) {
B <- scenes[scenes$episodeId == z, ]
B <- B$sceneId
})
liste_scenes <- unlist(liste_scenes)
liste_acteurs <-
lapply(liste_scenes, function(e) {
T <- appearances[appearances$sceneId == e, ]
T <- T$name
})
liste_acteurs <- unique(unlist(liste_acteurs))
return(liste_acteurs)
}
#getCharacters(3, 4)
getEpisodes(2)
getEpisodes <- function(numSeas) {
A <- episodes[episodes$seasonNum == numSeas, ]
A$idAndTitle <- past(A$episodeNum, A$episodeTitle, sep=" ")
#liste_episodes <- A$episodeNum
#liste_Id <- A$episodeId
#return (as.data.frame(A))
return (A)
}
getEpisodes(2)
getEpisodes <- function(numSeas) {
A <- episodes[episodes$seasonNum == numSeas, ]
A$idAndTitle <- past(A$episodeNum, A$episodeTitle, sep=" ")
#liste_episodes <- A$episodeNum
#liste_Id <- A$episodeId
#return (as.data.frame(A))
return (A)
}
#'\code{getCharacters} '@return list of characters in episode according
#'@param numseas season number and
#'@param numEpisode episode number
getCharacters <- function(x, y) {
D <- getEpisodes(x)
D <- D[D$episodeNum == y, ]
D <- D$episodeId
liste_scenes <-
lapply(D, function(z) {
B <- scenes[scenes$episodeId == z, ]
B <- B$sceneId
})
liste_scenes <- unlist(liste_scenes)
liste_acteurs <-
lapply(liste_scenes, function(e) {
T <- appearances[appearances$sceneId == e, ]
T <- T$name
})
liste_acteurs <- unique(unlist(liste_acteurs))
return(liste_acteurs)
}
getEpisodes(2)
getEpisodes <- function(numSeas) {
A <- episodes[episodes$seasonNum == numSeas, ]
A$idAndTitle <- paste(A$episodeNum, A$episodeTitle, sep=" ")
#liste_episodes <- A$episodeNum
#liste_Id <- A$episodeId
#return (as.data.frame(A))
return (A)
}
#'\code{getCharacters} '@return list of characters in episode according
#'@param numseas season number and
#'@param numEpisode episode number
getCharacters <- function(x, y) {
D <- getEpisodes(x)
D <- D[D$episodeNum == y, ]
D <- D$episodeId
liste_scenes <-
lapply(D, function(z) {
B <- scenes[scenes$episodeId == z, ]
B <- B$sceneId
})
liste_scenes <- unlist(liste_scenes)
liste_acteurs <-
lapply(liste_scenes, function(e) {
T <- appearances[appearances$sceneId == e, ]
T <- T$name
})
)
source("importFilesAndDatas.R")
#' getEpisodes est une fonction qui retourne les Ã©pisodes de la saison avec numSeas
#' comme paramÃ¨tre correspondant Ã la saison en questio
getEpisodes <- function(numSeas) {
A <- episodes[episodes$seasonNum == numSeas, ]
A$idAndTitle <- paste(A$episodeNum, A$episodeTitle, sep=" ")
#liste_episodes <- A$episodeNum
#liste_Id <- A$episodeId
#return (as.data.frame(A))
return (A)
}
#'\code{getCharacters} '@return list of characters in episode according
#'@param numseas season number and
#'@param numEpisode episode number
getCharacters <- function(x, y) {
D <- getEpisodes(x)
D <- D[D$episodeNum == y, ]
D <- D$episodeId
liste_scenes <-
lapply(D, function(z) {
B <- scenes[scenes$episodeId == z, ]
B <- B$sceneId
})
liste_scenes <- unlist(liste_scenes)
liste_acteurs <-
lapply(liste_scenes, function(e) {
T <- appearances[appearances$sceneId == e, ]
T <- T$name
})
liste_acteurs <- unique(unlist(liste_acteurs))
return(liste_acteurs)
}
#getCharacters(3, 4)
getEpisodes(3)
shiny::runApp()
View(episodes)
runApp()
runApp()
runApp()
